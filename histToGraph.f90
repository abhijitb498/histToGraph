
! PROGRAM TO PLOT FROM RAW HISTOGRAM FILE
! AUTHOR, ABHIJIT BAISHYA
! FIRST EDIT: 04/10/2021
! LAST EDIT: 07/10/2021


program histToGraph 
implicit none


real,allocatable :: hist(:),graph(:,:)
character(50) :: inname,outname,gpname,response
real :: lowlim,uplim
integer :: i,N,nbins,iostat

! CHECK FOR PROPER INPUT FORMAT AT THE TERMINAL, I.E. EITHER THE INPUT FILE HAS TO BE GIVEN, 
! IN WHICH CASE THE OUTPUT FILE WILL BE GENERATED BY THE PROGRAM OR INPUT FILE AS WELL AS OUTPUT FILE CAN BE GIVEN
if (iargc() < 1 .or. iargc() > 2) then 
   print*,'Input format is "./program inputfile" or "./program inputfile outputfile"'
   stop
endif 

! ASSIGNING INPUT FILE AND OUTPUT FILE NAMES TO VARIABLES
if (iargc() == 1) then 
   call getarg(1,inname)
   outname = 'graph_'//inname
elseif (iargc() == 2) then 
   call getarg(1,inname)
   call getarg(2,outname)
endif 

! GNUPLOT FILE FOR PLOTTING
gpname='gp_hist.gp'

! ASKING USER FOR NUMBER OF BINS, LOWER LIMIT AND UPPER LIMIT OF THE HISTOGRAM
print*,'Enter Number of bins, lower limit, upper limit:'
read*,nbins,lowlim,uplim

! OPENING FILES FOR READING AND WRITING 
open(10,file=inname,action='read')      ! OPENING INPUT HISTOGRAM FILE
open(11,file=outname,action='write')    ! OPENING OUPUT GRAPH FILE
open(12,file=gpname,action='write')

N = 0 ! NUMBER OF LINES
do    
   N=N+1
   read(10,*,iostat=iostat)
   if (iostat < 0) exit
enddo 

! ALLOCATING THE HISTOGRAM ARRAY
allocate(hist(N-1))  

rewind(10)  ! REWINDING FILE FROM EOF TO THE BEGINNING

! READING DATA POINTS FROM HISTOGRAM FILE
do i=1,N-1
   read(10,*)hist(i)
enddo 

! CALLING HIST_TO_GRAPH SUBROUTINE TO CONVERT HISTOGRAM TO GRAPH
call hist_to_graph(hist,nbins,lowlim,uplim,graph)

! WRITING GRAPH X,Y DATA INTO FILE
do i=1,nbins+1
    write(11,*)graph(i,:)
enddo 

! GENERATING GNUPLOT FILE FOR PLOTTING 
!write(12,*)'set term qt'
write(12,*)'set xrange[',lowlim,':',uplim,']'
write(12,*)'plot "',trim(outname),'" u 1:2 sm csplines' ! SPLINE CURVE WILL BE PLOTTED, IF YOU WANT USUAL LINE PLOT OR SCATTER PLOT, EDIT THIS LINE

! CLOSING OPEN FILES
close(10)
close(11)
close(12)

! DEALLOCATING THE HIST ARRAY TO FREE MEMORY
deallocate(hist)
deallocate(graph)

! PLOTTING COMMAND
print*,'Whether you want to plot the histogram? Y/N?'

do 
   read*,response 
   if (response == 'Y' .or. response == 'y') then 
      call execute_command_line('gnuplot -p gp_hist.gp')
      exit 
   elseif (response == 'N' .or. response == 'n') then 
      exit 
   else 
      print*,'Enter a valid command, e.g. Y/N'
   endif 
enddo 

! REMOVING OUTPUT GRAPH FILE, COMMENT OUT IF YOU NEEDED
print*,'Do you want to save the ouput graph file? Y/N?'

do 
read*,response 
if (response == 'Y' .or. response == 'y') then 
   exit 
elseif (response == 'N' .or. response == 'n') then 
   call execute_command_line('rm '//outname)
   exit 
else 
   print*,'Enter a valid command, e.g. Y/N'
endif 
enddo 

! REMOVING GNUPLOT FILE, COMMENT OUT IF NEEDED
call execute_command_line('rm gp_hist.gp')


contains


! SUBROUTINE TO CONVERT HISTOGRAM TO (X,Y) GRAPH FORMAT
subroutine hist_to_graph(hist,nbins,low,high,graph) 
implicit none

real,intent(in) :: hist(:),low,high
integer,intent(in) :: nbins
real,allocatable :: graph(:,:)
real :: step
integer :: i,j,N

allocate(graph(nbins+1,2))
N = size(hist)

step = (high-low)/nbins
forall (i=1:nbins+1) graph(i,1) = low + step*(i-1)

do i=1,N
   do j=0,nbins
         if ( hist(i) > (graph(j+1,1) - step/2.0) .and. hist(i) < (graph(j+1,1) + step/2.0) ) then
            graph(j+1,2) = graph(j+1,2) + 1.0
         exit
      endif
   enddo
enddo

return
end subroutine

end program
